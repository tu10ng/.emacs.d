



* finding in order to edit
** scroll with mouse
   #+BEGIN_SRC emacs-lisp
     (setq scroll-step 1
	   scroll-margin 2
	   scroll-conservatively 101
	   scroll-up-aggressively 0.01
	   scroll-down-aggressively 0.01)
   #+END_SRC** buffer switch
** shell relative
#+begin_src emacs-lisp
  (setq shell-command-prompt-show-cwd 1)
#+end_src

#+RESULTS:
: 1

** UTILS
*** Counsel
  #+BEGIN_SRC emacs-lisp
    (use-package counsel)
  #+END_SRC
*** Swiper
  #+BEGIN_SRC emacs-lisp
    (use-package swiper
      :ensure try
      :bind (("C-s"  . swiper)
	     ("M-x"  . counsel-M-x)
	     ("C-x C-f"  . counsel-find-file))
      :config
      (progn
	(ivy-mode 1)
	(setq ivy-use-virtual-buffers t)
	(setq ivy-display-style 'fancy)))

  #+END_SRC
*** Try
  #+BEGIN_SRC emacs-lisp
  (use-package try
    :defer t
    )

  #+END_SRC
*** Which Key
  #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :config (which-key-mode)
      )

  #+END_SRC

  #+RESULTS:
  : t

*** smex
    #+begin_src emacs-lisp
      (use-package smex)
    #+end_src
*** youdao-dictionary
    #+begin_src emacs-lisp
       (use-package youdao-dictionary)
       (global-set-key "\C-cw" 'youdao-dictionary-search)
       (global-set-key "\C-c\C-w" 'youdao-dictionary-search)
    #+end_src
*** jump to definition
    #+begin_src emacs-lisp
		  (use-package dumb-jump
			:defer t
      )
		  
		  (use-package xref
		        :defer t
)
		  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
		  (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
    #+end_src

    #+RESULTS:
    : xref-show-definitions-completing-read

* behavior & moving & outfit of emacs
** in total
*** message and gc
   #+begin_src emacs-lisp
     (setq garbage-collection-messages nil
	   large-file-warning-threshold nil)
     (setq inhibit-compacting-font-caches t)
     (setq confirm-kill-processes nil)
     (fset 'yes-or-no-p 'y-or-n-p)
     

     ;; (run-with-idle-timer 500 t 'zone)
     (run-with-idle-timer 30 t 'garbage-collect)
     
   #+end_src     

   #+RESULTS:
   : [nil 0 30 0 t garbage-collect nil idle 0]
*** sound
 #+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC  
**** rainbow-fart
   #+begin_src emacs-lisp
     
	;; (use-package rainbow-fart
	;;   :ensure t
	;;   :init (rainbow-fart-mode 1))
     
     ;; (add-to-list 'load-path "~/.emacs.d/site-lisp/rainbow-fart.el")
     ;; (require 'rainbow-fart)
     ;; (rainbow-fart-mode 1)
     
     
   #+end_src

   #+RESULTS:

** server
#+begin_src emacs-lisp
  (server-start)
#+end_src

#+RESULTS:

** frame
*** startup
**** maximize frame on startup and set title
    #+begin_src emacs-lisp
      (toggle-frame-maximized)
      ;;(add-to-list 'default-frame-alist '(fullscreen . maximized))
    #+end_src

    #+RESULTS:

**** startup-message
    #+begin_src emacs-lisp
      (setq inhibit-startup-message t)
      (defun startup-echo-area-message ()
	(if (daemonp)
	    ""
	  (substitute-command-keys
	   "")))
    #+end_src
*** bars
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
(set-frame-parameter nil 'undecorated t)  
#+END_SRC

#+RESULTS:

*** tranparent
#+BEGIN_SRC emacs-lisp
;; (set-frame-parameter nil 'alpha 75)
#+END_SRC
*** title
    #+begin_src emacs-lisp
      ;;(setq frame-title-format "Emacs@GNU_Project")
    #+end_src

*** theme
**** lazycat-theme
can modeline change its color overtime if it doesnot have any other functionalies?
  #+BEGIN_SRC emacs-lisp
    ;; (use-package tangotango-theme
    ;;   :ensure t
    ;;   )
    
    ;; (enable-theme 'tangotango)
    
    (add-to-list 'load-path (expand-file-name "~/.emacs.d/site-lisp/lazycat-theme"))
    (require 'lazycat-theme)
    (lazycat-theme-load-dark)
    (setq  lazycat-dark-brighter-modeline t)
    (setq
     lazycat-dark-brighter-comments t
     lazycat-dark-comment-bg t
     lazycat-dark-padded-modeline t)
  #+END_SRC

  #+RESULTS:
  : t

**** rainbow parentheses
  #+BEGIN_SRC emacs-lisp
    (use-package paren
      :ensure nil
      :hook (after-init . show-paren-mode)
      :init (setq show-paren-when-point-inside-paren t
		  show-paren-when-point-in-periphery t
		  show-paren-highlight-openparen t))
    
    (use-package rainbow-delimiters 
      :ensure t 
      :config
      ;; 设置每一级括号的颜色
      (set-face-foreground 'rainbow-delimiters-depth-1-face "gold") 
      (set-face-foreground 'rainbow-delimiters-depth-2-face "DodgerBlue1") 
      (set-face-foreground 'rainbow-delimiters-depth-3-face "lime green") 
      (set-face-foreground 'rainbow-delimiters-depth-4-face "deep pink") 
      (set-face-foreground 'rainbow-delimiters-depth-5-face "DarkOrange2")
      (set-face-foreground 'rainbow-delimiters-depth-6-face "turquoise") 
      (set-face-foreground 'rainbow-delimiters-depth-7-face "medium orchid") 
      (set-face-foreground 'rainbow-delimiters-depth-8-face "chartreuse3") 
      (set-face-foreground 'rainbow-delimiters-depth-9-face "cyan") 
      (set-face-bold 'rainbow-delimiters-depth-1-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-2-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-3-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-4-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-5-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-6-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-7-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-8-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-9-face "t") 
      :hook
      ((prog-mode . rainbow-delimiters-mode)
       (conf-mode . rainbow-delimiters-mode)
       (shell-mode . rainbow-delimiters-mode)
       (text-mode . rainbow-delimiters-mode)
       (org-mode . rainbow-delimiters-mode)
       (help-mode . rainbow-delimiters-mode)
       ))
    
  #+END_SRC

  #+RESULTS:
  | rainbow-delimiters-mode |
**** cursor
rainbow cursor
    #+begin_src emacs-lisp


     ;; we don't want the cursor vanish
     (blink-cursor-mode -1)
     
     (setq rainbow-color-list '("#FF0000";red
				"#FF5000"
				"#FF9F00";orange
				"#FFFF00";yellow
				"#BFFF00"
				"#00FF00";green
				"#00FFFF";
				"#0088FF"
				"#0000FF";blue
				"#5F00FF"
				"#8B00FF";purple
				"#CF00FF"
				"#FF0088"
				))
     ;; declair the variable
     (setq cursor-color-pointer 1)
     
     ;; declaire the function
     (defun cursor-color-change ()
       "Take a color from `rainbow-color-list' by the pointer.  
     The pointer moves by +1, and restore by taking mod.  "
       (setq cursor-color-pointer (% (1+ cursor-color-pointer)
				     (length rainbow-color-list)))
       (set-cursor-color (nth cursor-color-pointer
			  rainbow-color-list))
       )
     
     ;; main function.  gothrough the `rainbow-color-list' within 0.5s. calls `cursor-color-change' .  
     (run-with-timer ()
		     (/ .5 (length rainbow-color-list))
		     'cursor-color-change)
    #+end_src    

    #+RESULTS:
    : [nil 24869 1981 996153 0.038461538461538464 cursor-color-change nil nil 598000]

*** modeline
**** awesome-tray(modeline)
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/site-lisp/awesome-tray"))
  (require 'awesome-tray)
  (awesome-tray-mode 1)
  
  (setq awesome-tray-active-modules
	'("mode-name" "buffer-name" "parent-dir"
	 "battery"
	 "date" 
  ))
#+END_SRC

#+RESULTS:
| mode-name | buffer-name | parent-dir | battery | date |

*** posframe
#+BEGIN_SRC emacs-lisp
  (use-package posframe)
  
  ;; (add-to-list 'load-path (expand-file-name "~/.emacs.d/site-lisp/sdcv/"))
  ;; (require 'sdcv)
  
  ;; (setq sdcv-say-word-p t)
  ;; (setq sdcv-dictionary-data-dir "/usr/bin/stardict")
  
  ;; (setq sdcv-dictionary-simple-list ;setup dictionary list for simple search
  ;;       '("懒虫简明英汉词典" "懒虫简明汉英词典" "KDic11万英汉词典"))
  ;; (setq sdcv-dictionary-complete-list ;setup dictionary list for complete search
  ;;       '( "懒虫简明英汉词典" "英汉汉英专业词典" "XDICT英汉辞典" "stardict1.3英汉辞典" "WordNet" "XDICT汉英辞典" "Jargon" "懒虫简明汉英词典" "FOLDOC" "新世纪英汉科技大词典" "KDic11万英汉词典" "朗道汉英字典5.0" "CDICT5英汉辞典" "新世纪汉英科技大词典" "牛津英汉双解美化版"   )) 
#+END_SRC

#+RESULTS:

** buffer relative
*** startup
 #+BEGIN_SRC emacs-lisp
   (setq initial-scratch-message nil)
   (setq initial-buffer-choice nil
	 inhibit-startup-screen t)
   (setq initial-major-mode 'org-mode)   
 #+END_SRC

 #+RESULTS:
*** delete
  #+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
  #+END_SRC
*** zone
   #+begin_src emacs-lisp
     (setq idle-play-function '(zone)
	   idle-play-time 500
	   n 0)
     (while (< n (length idle-play-function))
       (run-with-idle-timer idle-play-time t (nth n idle-play-function))
       (setq n (1+ n)))
     (setq n 0)
   #+end_src

   #+RESULTS:
   : 0

** line relative  
*** relative-line number
  #+BEGIN_SRC emacs-lisp
    (use-package linum-relative)
    (line-number-mode nil)
  #+END_SRC

  #+RESULTS:
  : t

** word-relative
*** line wrap
   #+begin_src emacs-lisp
     (set-default 'truncate-lines t)
   #+end_src
** Window
 #+BEGIN_SRC emacs-lisp
   (setq split-width-threshold 80)
   (setq split-height-threshold nil)   

 #+END_SRC
** keybinding (navigation, etc.)
   #+begin_src emacs-lisp
     (global-set-key "\M-," 'beginning-of-buffer)
     (global-set-key "\M-." 'end-of-buffer)
     (global-set-key "\M->" 'xref-find-definitions-other-window)
     (require 'js)     (define-key js-mode-map (kbd "M-.") 'nil)
     
     (global-set-key "\C-xu" 'nil)     
     (global-set-key "\C-xl" 'nil)     
     (global-set-key "\C-@" 'nil)
     (global-set-key "\M-gj" 'pop-to-mark-command) 
     (global-set-key "\M-i" 'nil)     	
     (global-set-key (kbd "<f5>") 'apply-macro-to-region-lines)
     (global-set-key (kbd "<f6>") 'kmacro-edit-macro)
     (global-set-key "\C-@" 'nil)     	
     (global-set-key "\C-x\C-h" 'mark-whole-buffer)     
     (global-set-key "\C-xo" 'nil)
     (global-set-key "\M-s" '(eww-search-words))
     
     
     (defun move-to-window-line-top-bottom-relative (&optional arg)
       "Position point relative to window.
     
	  With a prefix argument ARG, move ARG lines down relative to your position.
     
	  With no argument, if pos is below half of window got to top;
	  otherwise, goto bottom. 
	  Successive calls position point at positions defined
	  by `recenter-positions'."
       (interactive "P")
       (cond
	(arg (move-to-window-line (+ arg (- (line-number-at-pos)
					    (save-excursion
					      (move-to-window-line 1)
					      (line-number-at-pos))))))	; Always respect ARG.
	(t
	 (setq recenter-last-op
	       (if (eq this-command last-command)
		   (car (or (cdr (member recenter-last-op recenter-positions))
			    recenter-positions))
		 (if (< (line-number-at-pos)
			(save-excursion
			  (move-to-window-line (/ (window-height) 2))
			  (line-number-at-pos)))
		     'bottom
		   'top)))
	 (let ((this-scroll-margin
		(min (max 0 scroll-margin)
		     (truncate (/ (window-body-height) 4.0)))))
	   (cond ((eq recenter-last-op 'middle)
		  (call-interactively 'move-to-window-line))
		 ((eq recenter-last-op 'top)
		  (move-to-window-line this-scroll-margin))
		 ((eq recenter-last-op 'bottom)
		  (move-to-window-line (- -1 this-scroll-margin)))
		 ((integerp recenter-last-op)
		  (move-to-window-line recenter-last-op))
		 ((floatp recenter-last-op)
		  (move-to-window-line (round (* recenter-last-op (window-height))))))))))
     
     (global-set-key "\M-r" 'move-to-window-line-top-bottom-relative)
     
     
     
     (defun other-window (count &optional all-frames)
       "Select another window in cyclic ordering of windows.
     COUNT specifies the number of windows to skip, starting with the
     selected window, before making the selection.  If COUNT is
     positive, skip COUNT windows forwards.  If COUNT is negative,
     skip -COUNT windows backwards.  COUNT zero means do not skip any
     window, so select the selected window.  In an interactive call,
     COUNT is the numeric prefix argument.  Return nil.
     
     If the `other-window' parameter of the selected window is a
     function and `ignore-window-parameters' is nil, call that
     function with the arguments COUNT and ALL-FRAMES.
     
     This function does not select a window whose `no-other-window'
     window parameter is non-nil.
     
     This function uses `next-window' for finding the window to
     select.  The argument ALL-FRAMES has the same meaning as in
     `next-window', but the MINIBUF argument of `next-window' is
     always effectively nil."
       (interactive "p")
       (let* ((window (selected-window))
	      (original-window window)
	      (function (and (not ignore-window-parameters)
			     (window-parameter window 'other-window)))
	      old-window old-count)
	 (if (functionp function)
	     (funcall function count all-frames)
	   ;; `next-window' and `previous-window' may return a window we are
	   ;; not allowed to select.  Hence we need an exit strategy in case
	   ;; all windows are non-selectable.
	   (catch 'exit
	     (while (> count 0)
	       (setq window (next-window window nil all-frames))
	       (cond
		((eq window old-window)
		 (when (= count old-count)
		   ;; Keep out of infinite loops.  When COUNT has not changed
		   ;; since we last looked at `window' we're probably in pone.
		   (throw 'exit nil)))
		((window-parameter window 'no-other-window)
		 (unless old-window
		   ;; The first non-selectable window `next-window' got us:
		   ;; Remember it and the current value of COUNT.
		   (setq old-window window)
		   (setq old-count count)))
		(t
		 (setq count (1- count)))))
	     (while (< count 0)
	       (setq window (previous-window window nil all-frames))
	       (cond
		((eq window old-window)
		 (when (= count old-count)
		   ;; Keep out of infinite loops.  When COUNT has not changed
		   ;; since we last looked at `window' we're probably in one.
		   (throw 'exit nil)))
		((window-parameter window 'no-other-window)
		 (unless old-window
		   ;; The first non-selectable window `previous-window' got
		   ;; us: Remember it and the current value of COUNT.
		   (setq old-window window)
		   (setq old-count count)))
		(t
		 (setq count (1+ count)))))
     
	     (when (and (eq window original-window)
			(called-interactively-p 'interactive))
	       (counsel-switch-buffer-other-window))
     
	     (select-window window)
	     ;; Always return nil.
	     nil))))
     
     (global-set-key "\M-m" 'other-window)
   #+end_src


   #+RESULTS:
   : other-window

* static form of codes
** ORG mode
*** outfit

**** org bullets
  #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :ensure t
      :config
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
    (setq org-bullets-bullet-list '("☰" "☷" "☯" "☭")
	  org-ellipsis " ▼")
  #+END_SRC

**** hide block
 #+BEGIN_SRC emacs-lisp
   ;; hide src blocks
   (setq org-hide-block-startup t)

 #+END_SRC

 #+RESULTS:
 : t

**** table font
  (let ((emacs-font-size 14)
	(emacs-font-name "WenQuanYi Micro Hei Mono"))
    (set-frame-font (format "%s-%s" (eval emacs-font-name) (eval emacs-font-size)))
    (set-fontset-font (frame-parameter nil 'font) 'unicode (eval emacs-font-name)))

  (with-eval-after-load 'org
    (defun org-buffer-face-mode-variable ()
      (interactive)
      (make-face 'width-font-face)
      (set-face-attribute 'width-font-face nil :font "等距更纱黑体 SC 15")
      (setq buffer-face-mode-face 'width-font-face)
      (buffer-face-mode))

    (add-hook 'org-mode-hook 'org-buffer-face-mode-variable))

*** global-org
#+begin_src elisp
  ;; (setq org-agenda-files '("~/org/gtd.org" "~/.emacs.d/myinit.org")) do it in custmz group
#+end_src

#+RESULTS:
| ~/org/gtd.org | ~/.emacs.d/myinit.org |

*** structure's behavior
**** cycle
 #+BEGIN_SRC emacs-lisp
   (setq org-cycle-emulate-tab t
	 org-cycle-global-at-bob t
	 )

 #+END_SRC
**** cycle
 #+BEGIN_SRC emacs-lisp
(require 'org-tempo)

 #+END_SRC

 #+RESULTS:
 : org-tempo

*** actions
**** keybinds
  #+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)
  #+END_SRC
**** capture
***** capture configurations
#+begin_src emacs-lisp
  (global-set-key "\C-cc" 'org-capture)
  (setq org-default-notes-file "~/org/gtd.org"
	org-capture-templates nil)

  ;; '(key   description  type         target                        template                 )
  ;; '("t"   "Task"       entry        (file+headline "" "Tasks")    "* TODO %?\n  %u\n  %a"  )
  ;;			item
  ;;			checkitem
  ;;			table-line
  ;;			plain


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; (add-to-list 'org-capture-templates		        ;;
  ;; 	     '("t" "Tasks"))			        ;;
  ;; (add-to-list 'org-capture-templates		        ;;
  ;; 	     '("tr" "Book Reading Task" entry	        ;;
  ;; 	       (file+olp "..." "..." "...")	        ;;
  ;; 	       "* TODO %^{书名}\n%u\n%a\n"	        ;;
  ;; 	       :clock-in t			        ;;
  ;; 	       :clock-resume t			        ;;
  ;; 	       ))				        ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  #+end_src

***** diary
  #+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
	       '("d" "diary" entry
		 (file+weektree "~/org/diary.org")
		 "* %U - %^{heading}\n  %?"
		 ))
  #+end_src

***** gtd
  #+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
	       '("g" "GTD"))
  (add-to-list 'org-capture-templates
	       '("gd" "daily things" entry
		 (file+headline "~/org/gtd.org" "daily things(intelectual)")
		 "* %^{What?}\n%^{description}\n%?"
		 :empty-lines 1
		 ))
  (add-to-list 'org-capture-templates
	       '("gp" "period things" entry
		 (file+headline "~/org/gtd.org" "period things")
		 "* %^{What?}\n%^{description}\n%?"
		 :empty-lines 1
		 ))
  (add-to-list 'org-capture-templates
	       '("gs" "school things" entry
		 (file+headline "~/org/gtd.org" "学校活动")
		 "* %^{What?}\n%^{description}\n%?"
		 :empty-lines 1
		 ))


#+end_src
***** billing
#+begin_src emacs-lisp
  (defun get-year-and-month ()
    (list (format-time-string "%Y年") (format-time-string "%m月")))

  (defun find-month-tree ()
    (let* ((path (get-year-and-month))
	   (level 1)
	   end)
      (unless (derived-mode-p 'org-mode)
	(error "Target buffer \"%s\" should be in Org mode" (current-buffer)))
      (goto-char (point-min))             ;移动到 buffer 的开始位置
      ;; 先定位表示年份的 headline，再定位表示月份的 headline
      (dolist (heading path)
	(let ((re (format org-complex-heading-regexp-format
			  (regexp-quote heading)))
	      (cnt 0))
	  (if (re-search-forward re end t)
	      (goto-char (point-at-bol))  ;如果找到了 headline 就移动到对应的位置
	    (progn                        ;否则就新建一个 headline
	      (or (bolp) (insert "\n"))
	      (if (/= (point) (point-min)) (org-end-of-subtree t t))
	      (insert (make-string level ?*) " " heading "\n"))))
	(setq level (1+ level))
	(setq end (save-excursion (org-end-of-subtree t t))))
      (org-end-of-subtree)))

  (add-to-list 'org-capture-templates
	       '("b" "billing" plain
		 (file+function "~/org/billing.org" find-month-tree)
		 " | %U | %^{类别} | %^{what?} | %^{金额} |"
		 :kill-buffer t
		 ))

#+end_src
***** contacts
#+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
	       '("c" "Contacs" entry
		 (file "~/org/contacts.org")
		 "* %^{姓名} %^{手机号}p %^{mail}p %^{住址}p\n\n  %?"
		 :empty-lines 1
		 ))
#+end_src
**** org-mouse
     #+begin_src emacs-lisp
       (setq org-mouse-features '(activate-checkboxes))
     #+end_src

*** functions
**** agenda
     #+begin_src emacs-lisp
       (setq-default org-agenda-include-diary nil)
     #+end_src
**** ox-reveal
 #+BEGIN_SRC emacs-lisp
	 (use-package ox-reveal
	   :commands (org-reveal)
	   :init
	   (add-hook 'after-init-hook #'org-reveal)
	   :config
	   (setq ;; org-reveal-root "file:///home/qb/.reveal.js"
		 org-reveal-theme "moon"
		 org-reveal-plugins '(classList markdown zoom notes)
		 ))
      ;; colors for blocks
	 (use-package htmlize
	       :defer t
)
 #+END_SRC
**** babel
 #+BEGIN_SRC emacs-lisp
   (org-babel-do-load-languages
	 'org-babel-load-languages
	 '((emacs-lisp . t)
	   (C . t)
	   (java . t)
	   (js . t)
	   (ruby . t)
	   (ditaa . t)
	   (python . t)
	   (shell . t)
	   (latex . t)
	   (plantuml . t)
	   (R . t)))
 #+END_SRC

*** org-plus-contrib
     #+begin_src emacs-lisp
;;       (use-package org-plus-contrib)
     #+end_src

     #+RESULTS:
     : t

** C mode
   #+begin_src emacs-lisp
     (use-package cc-mode)
     (add-hook 'c-mode-hook 'c-toggle-auto-hungry-state)
     
   #+end_src

   #+RESULTS:
   | c-toggle-auto-hungry-state | (c-toggle-auto-hungry-state 1) |



** python mode
    #+begin_src emacs-lisp
;;      (use-package elpy
;;	:config
;;	(elpy-enable))

      ;;(use-package jedi)
      ;;(use-package jedi-direx)
    #+end_src
** vue
    #+begin_src emacs-lisp
      (use-package lsp-mode
	:commands lsp)

      ;; (use-package company-lsp
      ;;   :after lsp-mode
      ;;   :config (push 'company-lsp company-backends))

      (use-package vue-mode
	:mode "\\.vue\\'"
	:config
	(add-hook 'vue-mode-hook #'lsp))

    #+end_src

** emacs-application-framework.git
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework-master/")
  (require 'eaf)
    (use-package eaf
      :load-path "~./emacs.d/site-lisp/emacs-application-framework-master"
      :custom
      (eaf-browser-continue-where-left-off t)
      :config
      (require 'eaf-jupyter)
      (require 'eaf-pdf-viewer)
      ;;    (require 'eaf-mermaid)
      (require 'eaf-system-monitor)
      (require 'eaf-video-player)
      (require 'eaf-terminal)
      (require 'eaf-vue-demo)
      (require 'eaf-org-previewer)
      (require 'eaf-file-browser)
      (require 'eaf-image-viewer)
      (require 'eaf-file-sender)
      (require 'eaf-browser)
      (require 'eaf-demo)
      (require 'eaf-file-manager)
      (setq eaf-browser-enable-adblocker t)
      (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
      (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;;    (eaf-bind-key take_photo "p" eaf-camera-keybinding)
      (eaf-bind-key nil "M-q" eaf-browser-keybinding))
  
  (setq eaf-kill-process-after-last-buffer-closed t
	eaf-start-python-process-when-require t)
#+END_SRC

#+RESULTS:
: t

** UTILS
*** crontab mode
#+begin_src emacs-lisp
  (use-package crontab-mode)
#+end_src

#+RESULTS:

*** projectile
    #+begin_src emacs-lisp

    #+end_src
*** awesome-pair
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/site-lisp/awesome-pair")
  (require 'awesome-pair)
  
  (dolist (hook (list
		 'emacs-lisp-mode-hook
		 'lisp-mode-hook
		 'lisp-interaction-mode-hook
		 ))
    (add-hook hook '(lambda () (awesome-pair-mode 1))))
  
  (global-set-key "\M-'" 'awesome-pair-wrap-double-quote)
  (global-set-key "\M-[" 'awesome-pair-wrap-bracket)
  (global-set-key "\M-{" 'awesome-pair-wrap-curly)
;;  (global-set-key "\M-9" 'awesome-pair-wrap-round)
;;  (global-set-key "\M-0" 'awesome-pair-unwrap)
  
  (global-set-key "\M-p" 'awesome-pair-jump-left)
  (global-set-key "\C-\M-n" 'awesome-pair-jump-right)
  (global-set-key "\M-n" 'awesome-pair-jump-right)
#+END_SRC

#+RESULTS:
: awesome-pair-jump-right

*** info help
  #+BEGIN_SRC emacs-lisp
    (use-package 
      info-colors 
    :defer t
      :hook ('Info-selection-hook . 'info-colors-fontify-node))

  #+END_SRC
* TODO deforming the structure of code block
can learn from lazy-cat's thing-edit and move-text
** IO
   #+BEGIN_SRC emacs-lisp
     (setq process-adaptive-read-buffering nil
	   read-process-output-max (* 1024 1024))
   #+END_SRC

   #+RESULTS:
   : 1048576

** word
   #+BEGIN_SRC emacs-lisp
     (global-subword-mode 1)
     (defun kill-word-at-point () 
       "Kill characters at point or forward"
       (interactive)
       (forward-word)
       (kill-word -1))
     
     (global-set-key "\M-d" 'kill-word-at-point)
   #+END_SRC

** replace
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-r" 'query-replace)
   #+END_SRC
** mark(jump and selection)
*** shift-selec-mode
too hard to activate
#+BEGIN_SRC emacs-lisp
  (setq shift-select-mode nil)
#+END_SRC    

#+RESULTS:

*** multiple-cursors
slow down speed not good
    #+begin_src emacs-lisp
	    ;; (use-package multiple-cursors)
	    
	    ;; 	  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
	    ;; 	  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
	    ;; 	  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
      ;;	  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
    #+end_src    

    #+RESULTS:
    : mc/mark-all-like-this

*** visible mark
    #+begin_src emacs-lisp
      (defface visible-mark-face1
	'((((type tty) (class mono)))
	  (t (:background "gold")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face2
	'((((type tty) (class mono)))
	  (t (:background "DodgerBlue1")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face3
	'((((type tty) (class mono)))
	  (t (:background "lime green")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face4
	'((((type tty) (class mono)))
	  (t (:background "deep pink")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face5
	'((((type tty) (class mono)))
	  (t (:background "DarkOrange2")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face5
	'((((type tty) (class mono)))
	  (t (:background "turquoise")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (use-package visible-mark)
      (global-visible-mark-mode 1) ;; or add (visible-mark-mode) to specific hooks
      (setq visible-mark-max 4)
      (setq visible-mark-faces `(visible-mark-face1
				 visible-mark-face2
				 visible-mark-face3
				 visible-mark-face4
				 visible-mark-face5
				 visible-mark-face6      
				 ))
      
      
      
    #+end_src

    #+RESULTS:
    | visible-mark-face1 | visible-mark-face2 | visible-mark-face3 | visible-mark-face4 | visible-mark-face5 | visible-mark-face6 |

*** register
   #+BEGIN_SRC emacs-lisp
     (setq register-preview-delay nil
	   bookmark-save-flag 1
	   bookmark-search-size 50)
     ;; (global-set-key "\C-z" 'jump-to-register)
     ;; (global-set-key "\C-xr" 'point-to-register)
     
   #+END_SRC

   #+RESULTS:
   : 50

** line
*** line move
  #+BEGIN_SRC emacs-lisp
    (setq  line-move-ignore-invisible t
	   next-line-add-newlines t)
  #+END_SRC
*** open newline above and below 
#+BEGIN_SRC emacs-lisp
  ;;I want to start a newline acts like this in global mode like o in vim
  ;; new code referenced to lazycat's open-newline.el
  (defun open-newline-below()
    (interactive)
    (end-of-line)
    (open-line 1)
    (call-interactively 'next-line 1)
    (if (not (member major-mode '(haskell-mode org-mode literate-haskell-mode)))
	(indent-according-to-mode)
      (beginning-of-line)))
  ;;  (move-end-of-line 1)
  ;;  (newline-and-indent))
  
  (global-set-key "\C-o" 'open-newline-below)
  
  (defun open-newline-above()
    (interactive)
    (beginning-of-line)
    (open-line 1)
    (if (not (member major-mode '(haskell-mode org-mode literate-haskell-mode)))
	(indent-according-to-mode)
      (beginning-of-line)))
    ;; (line-move -1)
    ;; (move-end-of-line 1)
    ;; (newline-and-indent))
  
  (global-set-key "\M-o" 'open-newline-above)
  
  
  
  
  
#+END_SRC

#+RESULTS:
: open-newline-above
** fill collomn
  #+BEGIN_SRC emacs-lisp
    (setq-default fill-column 78)
  #+END_SRC
** UTILS
*** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    ;; :hook
    ;; ((prog-mode . company-mode)
    ;;  (conf-mode . company-mode)
    ;;  (shell-mode . company-mode))
    )
  (add-hook 'after-init-hook 'global-company-mode)
  
  (use-package company-tabnine
    :ensure t
    )
  
  (add-to-list 'company-backends #'company-tabnine)
  (setq company-idle-delay 0)
  (setq company-show-numbers t)
  
  ;; The free version of TabNine is good enough,
  ;; and below code is recommended that TabNine not always
  ;; prompt me to purchase a paid version in a large project.
  (defadvice company-echo-show (around disable-tabnine-upgrade-message activate)
    (let ((company-message-func (ad-get-arg 0)))
      (when (and company-message-func
		 (stringp (funcall company-message-func)))
	(unless (string-match "The free version of TabNine only indexes up to" (funcall company-message-func))
	  ad-do-it))))
  
  (define-key company-mode-map (kbd "C-j") 'company-complete-selection)
  (define-key company-active-map (kbd "C-n") 'nil)
  (define-key company-active-map (kbd "C-p") 'nil)
  
  
  #+END_SRC

  #+RESULTS:
*** magit
    #+begin_src emacs-lisp
	    (use-package magit
	          :defer t
)
	      ;; :init (setq magit-completing-read-function 'ivy-completing-read))
	      ;;   (use-package diff-hl)
      
    #+end_src

    #+RESULTS:
*** quickrun
    #+begin_src emacs-lisp
	     (use-package quickrun
	           :defer t
)
      
      
    #+end_src
*** flycheck
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
          :defer t

      :hook
      (prog-mode . flycheck-mode))
    (setq flycheck-javascript-eslint-executable "~/node_modules/.bin/eslint")
  #+END_SRC

*** figlet
    #+begin_src emacs-lisp
	    (use-package figlet
	          :defer t
)
    #+end_src

    #+RESULTS:

*** chinese py input method
**** rime's match is awful
#+begin_src elisp
  ;; (use-package rime)
  ;; (setq rime-show-candidate 'popup
  ;;       rime-popup-style 'vertical)
#+end_src

#+RESULTS:
**** pyim
#+begin_src elisp
  (use-package pyim)
  (pyim-default-scheme 'quanpin)
  (if (posframe-workable-p)
      (setq pyim-page-tooltip 'posframe)
    (setq pyim-page-tooltip 'popup))
  
  (setq pyim-page-length 9)
  (setq pyim-indicator-list (list #'pyim-indicator-with-posframe))
  
  
  (use-package pyim-basedict)
  (pyim-basedict-enable)
  
  (add-to-list 'load-path "~/.emacs.d/site-lisp/pyim-greatdict")  
  (require 'pyim-greatdict)
  (pyim-greatdict-enable)
  
#+end_src

#+RESULTS:
: t

* about leaving
** backup
 #+BEGIN_SRC emacs-lisp
 (setq make-backup-files nil)

 #+END_SRC
** auto-save 
 #+BEGIN_SRC emacs-lisp
   (setq auto-save-default nil)
   (setq auto-save-idle 1)
   (defun auto-save-buffers ()
     (interactive)
     (let ((auto-save-buffer-list))
       (save-excursion
	 (dolist (buf (buffer-list))
	   (set-buffer buf)
	   (if (and (buffer-file-name) (buffer-modified-p))
	       (progn
		 (push (buffer-name) auto-save-buffer-list)
		 (with-temp-message "" (basic-save-buffer))
		 ))))))

   (defun auto-save-enable ()
     (interactive)
     (run-with-idle-timer auto-save-idle t #'auto-save-buffers))

   (auto-save-enable)
 #+END_SRC

 #+RESULTS:
 : [nil 0 1 0 t auto-save-buffers nil idle 0]
 
** Restart Emacs
 #+BEGIN_SRC emacs-lisp
 (use-package restart-emacs
    :defer t
   )

 #+END_SRC


* MAYBE USEFUL AREA





