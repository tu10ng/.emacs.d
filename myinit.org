

* BENCHMARK
#+begin_src emacs-lisp
  (use-package benchmark-init)
  (benchmark-init/activate)
#+end_src



* finding 
** scroll with mouse
   #+BEGIN_SRC emacs-lisp
     (setq scroll-step 1
	   scroll-margin 2
	   scroll-conservatively 101
	   scroll-up-aggressively 0.01
	   scroll-down-aggressively 0.01)
   #+END_SRC** buffer switch
** shell relative
#+begin_src emacs-lisp
  (setq shell-command-prompt-show-cwd 1)
#+end_src

#+RESULTS:
: 1

** Swiper
  #+BEGIN_SRC emacs-lisp
    (use-package swiper
      :ensure try
      :bind (("C-s"  . swiper))
)
    
  #+END_SRC

  #+RESULTS:
  : swiper

** Counsel
  #+BEGIN_SRC emacs-lisp
    (use-package counsel
      :bind
      ("M-x"  . counsel-M-x)
      ("C-x C-f"  . counsel-find-file)
      :config
      (progn
	(ivy-mode 1)
	(setq ivy-use-virtual-buffers t)
	(setq ivy-display-style 'fancy))      
    )
  #+END_SRC

  #+RESULTS:
  : counsel-find-file

** ivy rich
  #+BEGIN_SRC emacs-lisp
    ;; show documentation string
    (use-package ivy-rich
      :init (ivy-rich-mode 1))
  #+END_SRC

  #+RESULTS:

** helpful
#+begin_src emacs-lisp
  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+end_src

#+RESULTS:
: helpful-key

** Try
  #+BEGIN_SRC emacs-lisp
  (use-package try
    :defer t
    )

  #+END_SRC
** Which Key
  #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :config (which-key-mode)
      )

  #+END_SRC

  #+RESULTS:
  : t

** smex
    #+begin_src emacs-lisp
      (use-package smex)
    #+end_src
** youdao-dictionary
    #+begin_src emacs-lisp
      (use-package youdao-dictionary
	:bind (("M-s" . youdao-dictionary-search-at-point+)))
      
    #+end_src
** jump to definition
    #+begin_src emacs-lisp
      (use-package dumb-jump
	:defer t
	)
      
      (use-package xref
	:defer t
	)
      (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
      (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
    #+end_src

    #+RESULTS:
    : xref-show-definitions-completing-read

* feeling
** in total
*** message and gc
   #+begin_src emacs-lisp
     (setq garbage-collection-messages nil
	   large-file-warning-threshold nil)
     (setq inhibit-compacting-font-caches t)
     (setq confirm-kill-processes nil)
     (fset 'yes-or-no-p 'y-or-n-p)
     

     ;; (run-with-idle-timer 500 t 'zone)
     (run-with-idle-timer 30 t 'garbage-collect)
     
   #+end_src     

   #+RESULTS:
   : [nil 0 30 0 t garbage-collect nil idle 0]
*** sound
 #+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC  
**** rainbow-fart
   #+begin_src emacs-lisp
     ;; (add-to-list 'load-path "~/.emacs.d/site-lisp/")

     ;; (use-package rainbow-fart

     ;;   :init (rainbow-fart-mode 1))
     ;; (setq rainbow-fart-keyword-interval 0)


   #+end_src

   #+RESULTS:
   : t

** server
#+begin_src emacs-lisp
  (require 'server)
  (or (eq (server-running-p) t)
      (server-start))
#+end_src

#+RESULTS:
: t

** frame
*** startup
**** maximize frame on startup and set title
    #+begin_src emacs-lisp
      (toggle-frame-maximized)
      ;;(add-to-list 'default-frame-alist '(fullscreen . maximized))
    #+end_src

    #+RESULTS:

**** startup-message
    #+begin_src emacs-lisp
      (setq inhibit-startup-message t)
      (defun startup-echo-area-message ()
	(if (daemonp)
	    ""
	  (substitute-command-keys
	   "")))
    #+end_src
*** bars
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
(set-frame-parameter nil 'undecorated t)  
#+END_SRC

#+RESULTS:

*** tranparent
#+BEGIN_SRC emacs-lisp
;; (set-frame-parameter nil 'alpha 75)
#+END_SRC

*** theme
**** lazycat-theme
can modeline change its color overtime if it doesnot have any other functionalies?
  #+BEGIN_SRC emacs-lisp
    ;; (use-package tangotango-theme
    ;;   
    ;;   )
    
    ;; (enable-theme 'tangotango)
    
    (add-to-list 'load-path (expand-file-name "~/.emacs.d/site-lisp/lazycat-theme"))
    (require 'lazycat-theme)
    (lazycat-theme-load-dark)
    (setq  lazycat-dark-brighter-modeline t)
    (setq
     lazycat-dark-brighter-comments t
     lazycat-dark-comment-bg t
     lazycat-dark-padded-modeline t)
  #+END_SRC

  #+RESULTS:
  : t

**** rainbow parentheses
  #+BEGIN_SRC emacs-lisp
    (use-package paren
      :ensure nil
      :hook (after-init . show-paren-mode)
      :init (setq show-paren-when-point-inside-paren t
		  show-paren-when-point-in-periphery t
		  show-paren-highlight-openparen t))
    
    (use-package rainbow-delimiters 
       
      :config
      ;; 设置每一级括号的颜色
      (set-face-foreground 'rainbow-delimiters-depth-1-face "gold") 
      (set-face-foreground 'rainbow-delimiters-depth-2-face "DodgerBlue1") 
      (set-face-foreground 'rainbow-delimiters-depth-3-face "lime green") 
      (set-face-foreground 'rainbow-delimiters-depth-4-face "deep pink") 
      (set-face-foreground 'rainbow-delimiters-depth-5-face "DarkOrange2")
      (set-face-foreground 'rainbow-delimiters-depth-6-face "turquoise") 
      (set-face-foreground 'rainbow-delimiters-depth-7-face "medium orchid") 
      (set-face-foreground 'rainbow-delimiters-depth-8-face "chartreuse3") 
      (set-face-foreground 'rainbow-delimiters-depth-9-face "cyan") 
      (set-face-bold 'rainbow-delimiters-depth-1-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-2-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-3-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-4-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-5-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-6-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-7-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-8-face "t") 
      (set-face-bold 'rainbow-delimiters-depth-9-face "t") 
      :hook
      ((prog-mode . rainbow-delimiters-mode)
       (conf-mode . rainbow-delimiters-mode)
       (shell-mode . rainbow-delimiters-mode)
       (text-mode . rainbow-delimiters-mode)
       (org-mode . rainbow-delimiters-mode)
       (help-mode . rainbow-delimiters-mode)
       ))
    
  #+END_SRC

  #+RESULTS:
  | rainbow-delimiters-mode |
**** cursor
rainbow cursor
    #+begin_src emacs-lisp


     ;; we don't want the cursor vanish
     (blink-cursor-mode -1)
     
     (setq rainbow-color-list '("#FF0000";red
				"#FF5000"
				"#FF9F00";orange
				"#FFFF00";yellow
				"#BFFF00"
				"#00FF00";green
				"#00FFFF";
				"#0088FF"
				"#0000FF";blue
				"#5F00FF"
				"#8B00FF";purple
				"#CF00FF"
				"#FF0088"
				))
     ;; declair the variable
     (setq cursor-color-pointer 1)
     
     ;; declaire the function
     (defun cursor-color-change ()
       "Take a color from `rainbow-color-list' by the pointer.  
     The pointer moves by +1, and restore by taking mod.  "
       (setq cursor-color-pointer (% (1+ cursor-color-pointer)
				     (length rainbow-color-list)))
       (set-cursor-color (nth cursor-color-pointer
			  rainbow-color-list))
       )
     
     ;; main function.  gothrough the `rainbow-color-list' within 0.5s. calls `cursor-color-change' .  
     (run-with-timer ()
		     (/ .5 (length rainbow-color-list))
		     'cursor-color-change)
    #+end_src    

    #+RESULTS:
    : [nil 24869 1981 996153 0.038461538461538464 cursor-color-change nil nil 598000]

*** modeline
**** awesome-tray(modeline)
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/site-lisp/awesome-tray"))
  (require 'awesome-tray)
  (awesome-tray-mode 1)
  
  (setq awesome-tray-active-modules
	'("mode-name" "buffer-name" "parent-dir"
	 "battery"
	 "date" 
  ))
#+END_SRC

#+RESULTS:
| mode-name | buffer-name | parent-dir | battery | date |

*** posframe
#+BEGIN_SRC emacs-lisp
  (use-package posframe)
  
 #+END_SRC

** buffer relative
*** startup
 #+BEGIN_SRC emacs-lisp
   (setq initial-scratch-message nil)
   (setq initial-buffer-choice nil
	 inhibit-startup-screen t)
   (setq initial-major-mode 'org-mode)   
 #+END_SRC

 #+RESULTS:
*** delete
  #+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
  #+END_SRC
*** zone
   #+begin_src emacs-lisp
     ;; (setq idle-play-function '(zone)
     ;;       idle-play-time 500
     ;;       n 0)
     ;; (while (< n (length idle-play-function))
     ;;   (run-with-idle-timer idle-play-time t (nth n idle-play-function))
     ;;   (setq n (1+ n)))
     ;; (setq n 0)
   #+end_src

   #+RESULTS:

** line relative  
*** relative-line number
  #+BEGIN_SRC emacs-lisp
    (use-package linum-relative)
    (line-number-mode nil)
    
    ;; its not working
    ;; (dolist (mode '(term-mode-hook
    ;; 		shell-mode-hook
    ;; 		treemacs-mode-hook
    ;; 		eshell-mode-hook))
    ;;   (add-hook mode (lambda () (linum-relative-toggle))))
  #+END_SRC

  #+RESULTS:

** word-relative
*** line wrap
   #+begin_src emacs-lisp
     (set-default 'truncate-lines t)
   #+end_src
** Window
 #+BEGIN_SRC emacs-lisp
   (setq split-width-threshold 80)
   (setq split-height-threshold 50)   

 #+END_SRC

 #+RESULTS:
 : 50

** keybinding (navigation, etc.)
   #+begin_src emacs-lisp
     (global-set-key "\M-," 'lsp-find-references)
     (global-set-key "\M-." 'xref-find-definitions-other-window)

     (global-set-key (kbd "<f5>") 'apply-macro-to-region-lines)
     (global-set-key (kbd "<f6>") 'kmacro-edit-macro)

     (defun tl/upcase-word (ARG)
       "backward upcasing"
       (interactive "p")
       (upcase-word (- ARG)))

     (defun tl/downcase-word (ARG)
       "backward upcasing"
       (interactive "p")
       (downcase-word (- ARG)))

     (defun tl/capitalize-word (ARG)
       "backward upcasing"
       (interactive "p")
       (capitalize-word (- ARG)))

     (global-set-key (kbd "M-l") 'tl/downcase-word)
     (global-set-key (kbd "M-u") 'tl/upcase-word)
     (global-set-key (kbd "M-c") 'tl/capitalize-word)

     (defun tl/exchange-keys ()
       "exchange some keys' behaviour, like '1' will ouput '!', '!' output '1'"
       (interactive)
       (global-set-key (kbd "1") (lambda () (interactive) (insert "!")))
       (global-set-key (kbd "2") (lambda () (interactive) (insert "@")))
       (global-set-key (kbd "3") (lambda () (interactive) (insert "#")))
       (global-set-key (kbd "4") (lambda () (interactive) (insert "$")))
       (global-set-key (kbd "5") (lambda () (interactive) (insert "%")))
       (global-set-key (kbd "6") (lambda () (interactive) (insert "^")))
       (global-set-key (kbd "7") (lambda () (interactive) (insert "&")))
       (global-set-key (kbd "8") (lambda () (interactive) (insert "*")))
       ;;       (global-set-key (kbd "9") (lambda () (interactive) (insert "(")))
       ;;       (global-set-key (kbd "0") (lambda () (interactive) (insert ")")))
       (global-set-key (kbd "!") (lambda () (interactive) (insert "1")))
       (global-set-key (kbd "@") (lambda () (interactive) (insert "2")))
       (global-set-key (kbd "#") (lambda () (interactive) (insert "3")))
       (global-set-key (kbd "$") (lambda () (interactive) (insert "4")))
       (global-set-key (kbd "%") (lambda () (interactive) (insert "5")))
       (global-set-key (kbd "^") (lambda () (interactive) (insert "6")))
       (global-set-key (kbd "&") (lambda () (interactive) (insert "7")))
       (global-set-key (kbd "*") (lambda () (interactive) (insert "8")))
       ;;       (global-set-key (kbd "(") (lambda () (interactive) (insert "9")))
       ;;       (global-set-key (kbd ")") (lambda () (interactive) (insert "0")))
  
       )

     ;; 这样的键盘布局对于人类来说为时尚早……
     ;;     (add-hook 'after-init-hook 'tl/exchange-keys)


     ;; (setq w32-pass-lwindow-to-system nil
     ;;       w32-lwindow-modifier 'super
     ;;       w32-register-hot-key [s-])






     (defun other-window (count &optional all-frames)
       "Select another window in cyclic ordering of windows.
		    COUNT specifies the number of windows to skip, starting with the
		    selected window, before making the selection.  If COUNT is
		    positive, skip COUNT windows forwards.  If COUNT is negative,
		    skip -COUNT windows backwards.  COUNT zero means do not skip any
		    window, so select the selected window.  In an interactive call,
		    COUNT is the numeric prefix argument.  Return nil.
     
		    If the `other-window' parameter of the selected window is a
		    function and `ignore-window-parameters' is nil, call that
		    function with the arguments COUNT and ALL-FRAMES.
     
		    This function does not select a window whose `no-other-window'
		    window parameter is non-nil.
     
		    This function uses `next-window' for finding the window to
		    select.  The argument ALL-FRAMES has the same meaning as in
		    `next-window', but the MINIBUF argument of `next-window' is
		    always effectively nil."
       (interactive "p")
       (let* ((window (selected-window))
	      (original-window window)
	      (function (and (not ignore-window-parameters)
			     (window-parameter window 'other-window)))
	      old-window old-count)
	 (if (functionp function)
	     (funcall function count all-frames)
	   ;; `next-window' and `previous-window' may return a window we are
	   ;; not allowed to select.  Hence we need an exit strategy in case
	   ;; all windows are non-selectable.
	   (catch 'exit
	     (while (> count 0)
	       (setq window (next-window window nil all-frames))
	       (cond
		((eq window old-window)
		 (when (= count old-count)
		   ;; Keep out of infinite loops.  When COUNT has not changed
		   ;; since we last looked at `window' we're probably in pone.
		   (throw 'exit nil)))
		((window-parameter window 'no-other-window)
		 (unless old-window
		   ;; The first non-selectable window `next-window' got us:
		   ;; Remember it and the current value of COUNT.
		   (setq old-window window)
		   (setq old-count count)))
		(t
		 (setq count (1- count)))))
	     (while (< count 0)
	       (setq window (previous-window window nil all-frames))
	       (cond
		((eq window old-window)
		 (when (= count old-count)
		   ;; Keep out of infinite loops.  When COUNT has not changed
		   ;; since we last looked at `window' we're probably in one.
		   (throw 'exit nil)))
		((window-parameter window 'no-other-window)
		 (unless old-window
		   ;; The first non-selectable window `previous-window' got
		   ;; us: Remember it and the current value of COUNT.
		   (setq old-window window)
		   (setq old-count count)))
		(t
		 (setq count (1+ count)))))
	
	     (when (and (eq window original-window)
			(called-interactively-p 'interactive))
	       (counsel-switch-buffer-other-window))
	
	     (select-window window)
	     ;; Always return nil.
	     nil))))

     (global-set-key "\M-i" 'other-window)
     (global-set-key "\C-xo" 'other-window)


   #+end_src


   #+RESULTS:
   : other-window

* forming
** lsp
#+begin_src emacs-lisp
  (use-package yasnippet
    :config (yas-global-mode))
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook ((lsp-mode . lsp-enable-which-key-integration)
	   (java-mode . #'lsp-deferred))
    :init (setq lsp-keymap-prefix "C-c l"
		lsp-enable-file-watchers nil
		read-process-output-max (* 100 1024 1024) ;100 mb
		lsp-completion-provider :capf
		lsp-enable-indentation nil
		lsp-enable-on-type-formatting nil
		)
    :config (setq lsp-intelephense-multi-root nil)
    ;;  (with-eval-after-load 'lsp-intelephense
    ;;    (setf (lsp--client-multi-root (gethash 'iph lsp-clients)) nil))
    :custom
    (lsp-headerline-breadcrumb-enable nil)
    (lsp-restart 'auto-restart)
    )
  
  ;;	   lsp-completion-enable-additional-text-edit nil))
  
  (use-package hydra)
  (use-package lsp-ui
    :custom
    (lsp-ui-doc-position 'top))
  
  (use-package lsp-java)
  ;;  :hook (java-mode . lsp))
  (add-hook 'java-mode-hook #'lsp)
  ;;(setq lsp-java-workspace-dir
  (use-package dap-mode
    :after lsp-mode
    :config (dap-auto-configure-mode))
  (use-package dap-java
    :ensure nil)
  (use-package helm)
  ;;    :config (helm-mode))
  (use-package helm-lsp
    :after (lsp-mode)
    :commands (helm-lsp-workspace-symbol))
  ;; :init (define-key lsp-mode-map [remap xref-find-apropos] #'helm-lsp-workspace-symbol))
  
  ;; (use-package lsp-treemacs)
  
  
  
  
#+end_src

#+RESULTS:

** ORG mode
*** outfit
**** org bullets
  #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      
      :config
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
    (setq org-bullets-bullet-list '("☰" "☷" "☯" "☭")
	  org-ellipsis " ▼")
  #+END_SRC

**** hide block
 #+BEGIN_SRC emacs-lisp
   ;; hide src blocks
   (setq org-hide-block-startup t)

 #+END_SRC

 #+RESULTS:
 : t

**** table font
  (let ((emacs-font-size 14)
	(emacs-font-name "WenQuanYi Micro Hei Mono"))
    (set-frame-font (format "%s-%s" (eval emacs-font-name) (eval emacs-font-size)))
    (set-fontset-font (frame-parameter nil 'font) 'unicode (eval emacs-font-name)))

  (with-eval-after-load 'org
    (defun org-buffer-face-mode-variable ()
      (interactive)
      (make-face 'width-font-face)
      (set-face-attribute 'width-font-face nil :font "等距更纱黑体 SC 15")
      (setq buffer-face-mode-face 'width-font-face)
      (buffer-face-mode))

    (add-hook 'org-mode-hook 'org-buffer-face-mode-variable))
**** cycle
 #+BEGIN_SRC emacs-lisp
   (setq org-cycle-emulate-tab t
	 org-cycle-global-at-bob t
	 )

(require 'org-tempo)

 #+END_SRC


*** agenda
     #+begin_src emacs-lisp
       (setq-default org-agenda-include-diary nil)
     #+end_src
*** export


 #+BEGIN_SRC emacs-lisp
   ;; (use-package ox-reveal
   ;;   :commands (org-reveal)
   ;;   :init
   ;;   (add-hook 'after-init-hook #'org-reveal)
   ;;   :config
   ;;   (setq org-reveal-root "~/.reveal.js"
   ;;    org-reveal-theme "moon"
   ;;    org-reveal-plugins '(classList markdown zoom notes)
   ;;    ))
   
   (setq org-export-headline-levels 1
	 org-export-with-broken-links 'mark
	 org-export-with-section-numbers nil
	 org-html-checkbox-type 'html
	 org-html-doctype "html5"
	 org-html-html5-fancy t)
   
   ;; colors for blocks
   (use-package htmlize
     :defer t
     )
 #+END_SRC

 #+RESULTS:
*** babel
 #+BEGIN_SRC emacs-lisp
   (org-babel-do-load-languages
	 'org-babel-load-languages
	 '((emacs-lisp . t)
	   (C . t)
	   (java . t)
	   (js . t)
	   (ruby . t)
	   (ditaa . t)
	   (python . t)
	   (shell . t)
	   (latex . t)
	   (plantuml . t)
	   (R . t)))
 #+END_SRC

*** keybinds
  #+BEGIN_SRC emacs-lisp
;;    (global-set-key "\C-cl" 'org-store-link)
    (global-set-key "\C-ca" 'org-agenda)
    (global-set-key "\C-cb" 'org-iswitchb)
    (global-set-key "\C-cc" 'org-capture)
  #+END_SRC

  #+RESULTS:
  : org-capture
  
*** mouse
     #+begin_src emacs-lisp
       (setq org-mouse-features '(activate-checkboxes))
     #+end_src
** cc mode
   #+begin_src emacs-lisp
     (use-package cc-mode)
     (add-hook 'c-mode-common-hook 'c-toggle-auto-hungry-state)
     
     (define-key c-mode-base-map "\C-m" 'c-context-line-break)
;;     (define-key c-mode-base-map "9" (kbd "("))
;;     (define-key c-mode-base-map "0" (kbd ")"))
     
   #+end_src

   #+RESULTS:
** some modes
#+begin_src emacs-lisp
  (use-package fish-mode)
  (use-package lox-mode)
  (use-package php-mode)
;;  (use-package pdf-tools)
#+end_src

#+RESULTS:
** python
#+begin_src emacs-lisp
  (use-package lsp-pyright
    :hook (python-mode . (lambda ()
			   (require 'lsp-pyright)
			   (lsp-deferred))))
#+end_src

#+RESULTS:
| lambda | nil | (require 'lsp-pyright) | (lsp-deferred) |

** css
#+begin_src emacs-lisp
;;  (add-to-list 'load-path "~/.emacs.d/site-lisp/")
;;  (require 'css-sort-buffer)
#+end_src
** emacs-application-framework
#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework-master/")
  ;; (require 'eaf)
  ;;   (use-package eaf
  ;;     :load-path "~./emacs.d/site-lisp/emacs-application-framework-master"
  ;;     :custom
  ;;     (eaf-browser-continue-where-left-off t)
  ;;     :config
  ;;     (require 'eaf-jupyter)
  ;;     (require 'eaf-pdf-viewer)
  ;;     ;;    (require 'eaf-mermaid)
  ;;     (require 'eaf-system-monitor)
  ;;     (require 'eaf-video-player)
  ;;     (require 'eaf-terminal)
  ;;     (require 'eaf-vue-demo)
  ;;     (require 'eaf-org-previewer)
  ;;     (require 'eaf-file-browser)
  ;;     (require 'eaf-image-viewer)
  ;;     (require 'eaf-file-sender)
  ;;     (require 'eaf-browser)
  ;;     (require 'eaf-demo)
  ;;     (require 'eaf-file-manager)
  ;;     (setq eaf-browser-enable-adblocker t)
  ;;     (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;;     (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; ;;    (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;;     (eaf-bind-key nil "M-q" eaf-browser-keybinding))
  
  ;; (setq eaf-kill-process-after-last-buffer-closed t
  ;;       eaf-start-python-process-when-require t)
#+END_SRC

#+RESULTS:
: t

** crontab mode
#+begin_src emacs-lisp
  (use-package crontab-mode)
#+end_src

#+RESULTS:

** awesome-pair
#+BEGIN_SRC emacs-lisp
  ;;  (add-to-list 'load-path "~/.emacs.d/site-lisp/awesome-pair")
    ;; (require 'awesome-pair)
  
    ;; (dolist (hook (list
    ;; 		 'emacs-lisp-mode-hook
    ;; 		 'lisp-mode-hook
    ;; 		 'lisp-interaction-mode-hook
    ;; 		 ))
    ;;   (add-hook hook '(lambda () (awesome-pair-mode 1))))
  
    ;; (global-set-key "\M-p" 'awesome-pair-jump-left)
    ;; (global-set-key "\M-n" 'awesome-pair-jump-right)

#+END_SRC

#+RESULTS:
: awesome-pair-jump-right

** info help
  #+BEGIN_SRC emacs-lisp
    (use-package 
      info-colors 
    :defer t
      :hook ('Info-selection-hook . 'info-colors-fontify-node))

  #+END_SRC
** projectile
  #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :config (projectile-mode 1)
      :custom ((projectile-completion-system 'ivy))
      :bind-keymap
      ("C-c p" . projectile-command-map)
      :init
      (when (file-directory-p "~/Projects")
	(setq projectile-project-search-path '("~/Projects/")))
      (setq projectile-switch-project-action #'projectile-dired)
      )
    
    (use-package counsel-projectile
      :config (counsel-projectile-mode))
  #+END_SRC

  #+RESULTS:
  : t

** game and zone
*** speed-type
#+begin_src emacs-lisp
  (use-package speed-type)
  
#+end_src

#+RESULTS:

*** zone-nyan
#+begin_src emacs-lisp
  (use-package zone-nyan)
  
#+end_src

#+RESULTS:
*** autotetris
#+begin_src emacs-lisp
  (use-package autotetris-mode)
#+end_src

#+RESULTS:

*** flames of freedom
#+begin_src emacs-lisp
;;  (use-package flames-of-freedom)
#+end_src

#+RESULTS:

* deforming
** UTILS
*** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :after lsp-mode
    :bind
    (:map company-active-map
	  ("<tab>" . company-complete-selection)
	  ("C-j" .  company-complete-selection))
    (:map lsp-mode-map
	  ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0)
    )
  (add-hook 'after-init-hook 'global-company-mode)
  ;; (setq company-show-numbers t)
  
  (use-package company-tabnine
    )
  ;;(add-to-list 'company-backends #'company-tabnine)
  
  (defun company//sort-by-tabnine (candidates)
    (if (or (functionp company-backend)
	    (not (and (listp company-backend) (memq 'company-tabnine company-backend))))
	candidates
      (let ((candidates-table (make-hash-table :test #'equal))
	    candidates-1
	    candidates-2)
	(dolist (candidate candidates)
	  (if (eq (get-text-property 0 'company-backend candidate)
		  'company-tabnine)
	      (unless (gethash candidate candidates-table)
		(push candidate candidates-2))
	    (push candidate candidates-1)
	    (puthash candidate t candidates-table)))
	(setq candidates-1 (nreverse candidates-1))
	(setq candidates-2 (nreverse candidates-2))
	(nconc (seq-take candidates-1 1)	; number of items tabnine shows
	       (seq-take candidates-2 1)
	       (seq-drop candidates-1 1)
	       (seq-drop candidates-2 1)))))
  
  (add-to-list 'company-transformers 'company//sort-by-tabnine t)
  ;; `:separate`  使得不同 backend 分开排序
  (add-to-list 'company-backends '(company-capf :with company-tabnine :separate))
  
  
  
  
  
  ;; The free version of TabNine is good enough,
  ;; and below code is recommended that TabNine not always
  ;; prompt me to purchase a paid version in a large project.
  (defadvice company-echo-show (around disable-tabnine-upgrade-message activate)
    (let ((company-message-func (ad-get-arg 0)))
      (when (and company-message-func
		 (stringp (funcall company-message-func)))
	(unless (string-match "The free version of TabNine only indexes up to" (funcall company-message-func))
	  ad-do-it))))
  
  
  
  #+END_SRC

  #+RESULTS:
  : company-echo-show
*** magit
    #+begin_src emacs-lisp
      (use-package magit
	:defer t
	)
      ;; :init (setq magit-completing-read-function 'ivy-completing-read))
      (use-package diff-hl)
      (global-set-key (kbd "C-c g") 'magit-file-dispatch)
    #+end_src

    #+RESULTS:
    : magit-file-dispatch
*** quickrun
    #+begin_src emacs-lisp
      (use-package quickrun
	:bind ("C-c r" . quickrun)
	)
      
    #+end_src

    #+RESULTS:
    : quickrun

*** flycheck
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :init (global-flycheck-mode))
    
    (setq flycheck-javascript-eslint-executable "~/node_modules/.bin/eslint")
  #+END_SRC

  #+RESULTS:
  : ~/node_modules/.bin/eslint

*** figlet
    #+begin_src emacs-lisp
      (use-package figlet
	:defer t
	)
    #+end_src

    #+RESULTS:
*** ripgrep
    #+begin_src emacs-lisp
      (use-package ripgrep
	:defer t
	)
    #+end_src

    #+RESULTS:
*** chinese py input method
**** rime's match is awful
#+begin_src elisp
  ;; (use-package rime)
  ;; (setq rime-show-candidate 'popup
  ;;       rime-popup-style 'vertical)
#+end_src

#+RESULTS:
**** pyim
#+begin_src elisp
  (use-package pyim)
  (pyim-default-scheme 'quanpin)
  (if (posframe-workable-p)
      (setq pyim-page-tooltip 'posframe)
    (setq pyim-page-tooltip 'popup))

  (setq pyim-page-length 9)
  (setq pyim-indicator-list (list #'pyim-indicator-with-posframe))


  (use-package pyim-basedict)
  (pyim-basedict-enable)

  ;; (add-to-list 'load-path "~/.emacs.d/site-lisp/pyim-greatdict")  
  ;; (require 'pyim-greatdict)
  ;; (pyim-greatdict-enable)
  
#+end_src

#+RESULTS:
: t
** TODO learn from lazy-cat's thing-edit and move-text
** IO
   #+BEGIN_SRC emacs-lisp
     (setq process-adaptive-read-buffering nil
	   read-process-output-max (* 1024 1024))
   #+END_SRC

   #+RESULTS:
   : 1048576

** word
   #+BEGIN_SRC emacs-lisp
     (global-subword-mode 1)
   #+END_SRC

   #+RESULTS:
   : t

** replace
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-r" 'query-replace)
   #+END_SRC
** mark(jump and selection)
*** shift-selec-mode
too hard to activate
#+BEGIN_SRC emacs-lisp
  (setq shift-select-mode nil)
#+END_SRC    

#+RESULTS:

*** visible mark
    #+begin_src emacs-lisp
      (defface visible-mark-face1
	'((((type tty) (class mono)))
	  (t (:background "gold")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face2
	'((((type tty) (class mono)))
	  (t (:background "DodgerBlue1")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face3
	'((((type tty) (class mono)))
	  (t (:background "lime green")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face4
	'((((type tty) (class mono)))
	  (t (:background "deep pink")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face5
	'((((type tty) (class mono)))
	  (t (:background "DarkOrange2")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (defface visible-mark-face5
	'((((type tty) (class mono)))
	  (t (:background "turquoise")))
	"Example face which can be customized and added to subsequent face lists."
	:group 'visible-mark)
      
      (use-package visible-mark)
      (global-visible-mark-mode 1) ;; or add (visible-mark-mode) to specific hooks
      (setq visible-mark-max 4)
      (setq visible-mark-faces `(visible-mark-face1
				 visible-mark-face2
				 visible-mark-face3
				 visible-mark-face4
				 visible-mark-face5
				 visible-mark-face6      
				 ))
      
      
      
    #+end_src

    #+RESULTS:
    | visible-mark-face1 | visible-mark-face2 | visible-mark-face3 | visible-mark-face4 | visible-mark-face5 | visible-mark-face6 |

*** register
   #+BEGIN_SRC emacs-lisp
     (setq register-preview-delay nil
	   bookmark-save-flag 1
	   bookmark-search-size 50)
     
   #+END_SRC

   #+RESULTS:
   : 50

** line
*** line move
  #+BEGIN_SRC emacs-lisp
    (setq  line-move-ignore-invisible t
	   next-line-add-newlines t)
  #+END_SRC
*** open newline above and below 
acts like o in vim, code refered to lazycat's open-newline.el			 
#+BEGIN_SRC emacs-lisp
  (defun open-newline-below()
    (interactive)
    (end-of-line)
    (open-line 1)
    (call-interactively 'next-line 1)
    (if (not (member major-mode '(haskell-mode org-mode literate-haskell-mode)))
	(indent-according-to-mode)
      (beginning-of-line)))
  ;;  (move-end-of-line 1)
  ;;  (newline-and-indent))
  
  (global-set-key "\C-o" 'open-newline-below)
  
  (defun open-newline-above()
    (interactive)
    (beginning-of-line)
    (open-line 1)
    (if (not (member major-mode '(haskell-mode org-mode literate-haskell-mode)))
	(indent-according-to-mode)
      (beginning-of-line)))
    ;; (line-move -1)
    ;; (move-end-of-line 1)
    ;; (newline-and-indent))
  
  (global-set-key "\M-o" 'open-newline-above)
  
  
  
  
  
#+END_SRC

#+RESULTS:
: open-newline-above
** fill collomn
  #+BEGIN_SRC emacs-lisp
    (setq-default fill-column 78)
  #+END_SRC

* coming and leaving

** native compilation
#+begin_src emacs-lisp
  (setq comp-deferred-compilation t
	package-native-compile t
  )

#+end_src

#+RESULTS:
: t

** no backup
 #+BEGIN_SRC emacs-lisp
 (setq make-backup-files nil)

 #+END_SRC
** auto-save when idle
 #+BEGIN_SRC emacs-lisp
   (setq auto-save-default nil)
   (setq auto-save-idle 1)
   (defun auto-save-buffers ()
     (interactive)
     (let ((auto-save-buffer-list))
       (save-excursion
	 (dolist (buf (buffer-list))
	   (set-buffer buf)
	   (if (and (buffer-file-name) (buffer-modified-p))
	       (progn
		 (push (buffer-name) auto-save-buffer-list)
		 (with-temp-message "" (basic-save-buffer))
		 ))))))

   (defun auto-save-enable ()
     (interactive)
     (run-with-idle-timer auto-save-idle t #'auto-save-buffers))

   (auto-save-enable)
 #+END_SRC

 #+RESULTS:
 : [nil 0 1 0 t auto-save-buffers nil idle 0]
 
** Restart Emacs
 #+BEGIN_SRC emacs-lisp
 (use-package restart-emacs
    :defer t
   )

 #+END_SRC







